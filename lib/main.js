'use babel';

const fs = require('fs');
const readline = require('readline');
const path = require('path');

const { google } = require('googleapis');
const { GoogleAuth, JWT, OAuth2Client } = require('google-auth-library');

const { CompositeDisposable, Point, Range } = require('atom');

const opn = require('opn');
import AuthView from './auth-view';

const juice = require('juice');
const hljs = require('highlight.js'); // https://highlightjs.org/
const yaml = require('js-yaml');
const md = require('markdown-it')({
  html: true,
  linkify: atom.config.get('atom-gmail.linkify'),
  typographer: true,
  highlight: function(str, lang) {
    if (lang && hljs.getLanguage(lang)) {
      try {
        return '<pre class="hljs"><code>' +
          hljs.highlight(lang, str, true).value +
          '</code></pre>';
      } catch (__) {}
    }

    return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
  }
});

var css_options = [
  'agate', 'androidstudio', 'arduino-light', 'arta', 'ascetic', 'atelier-cave-dark',
  'atelier-cave-light', 'atelier-dune-dark', 'atelier-dune-light', 'atelier-estuary-dark',
  'atelier-estuary-light', 'atelier-forest-dark', 'atelier-forest-light', 'atelier-heath-dark',
  'atelier-heath-light', 'atelier-lakeside-dark', 'atelier-lakeside-light', 'atelier-plateau-dark',
  'atelier-plateau-light', 'atelier-savanna-dark', 'atelier-savanna-light', 'atelier-seaside-dark',
  'atelier-seaside-light', 'atelier-sulphurpool-dark', 'atelier-sulphurpool-light', 'atom-one-dark',
  'atom-one-light', 'brown-paper', 'codepen-embed', 'color-brewer', 'darcula', 'dark', 'darkula',
  'default', 'docco', 'dracula', 'far', 'foundation', 'github', 'github-gist', 'googlecode',
  'grayscale', 'gruvbox-dark', 'gruvbox-light', 'hopscotch', 'hybrid', 'idea', 'ir-black',
  'kimbie.dark', 'kimbie.light', 'magula', 'monokai', 'monokai-sublime', 'mono-blue', 'obsidian',
  'ocean', 'paraiso-dark', 'paraiso-light', 'pojoaque', 'purebasic', 'qtcreator_dark',
  'qtcreator_light', 'railscasts', 'rainbow', 'routeros', 'school-book', 'solarized-dark',
  'solarized-light', 'sunburst', 'tomorrow', 'tomorrow-night', 'tomorrow-night-blue',
  'tomorrow-night-bright', 'tomorrow-night-eighties', 'vs', 'vs2015', 'xcode', 'xt256', 'zenburn'
];

module.exports = {
  config: {
    client_secret: {
      title: 'Client Secret',
      type: 'string',
      default: '',
      description: 'The contents of the `client_secret.json` file downloaded from the Google Developers Console. See the Installation section of the README for instructions.',
      order: 1
    },
    oauth_token: {
      title: 'OAuth2 Token',
      type: 'string',
      default: '',
      description: 'OAuth2 token generated by atom-gmail:authenticate. Do not touch this manually.',
      order: 2
    },
    code_highlighting: {
      title: 'Code highlighting style',
      type: 'string',
      enum: css_options,
      default: 'github',
      description: 'See [https://highlightjs.org/static/demo/](https://highlightjs.org/static/demo/) to inspect styles.',
      order: 3
    },
    max_width: {
      title: 'Maximum width',
      type: 'string',
      default: '720px',
      description: 'Maximum width of email. Can be pixels or percent. See [here](https://www.w3schools.com/cssref/pr_dim_max-width.asp) for reference.',
      order: 4
    },
    centered: {
      title: 'Centered',
      type: 'boolean',
      default: true,
      description: 'Center text in email',
      order: 5
    },
    linkify: {
      title: 'Linkify',
      description: 'Autoconvert URL-like text to links. Note: Gmail often does this anyways.',
      type: 'boolean',
      default: false,
      order: 6
    }
  },

  authView: null,
  modalPanel: null,
  subscriptions: null,

  activate(state) {
    this.authView = new AuthView(state.authViewState);
    this.subscriptions = new CompositeDisposable;
    this.subscriptions.add(atom.commands.add('atom-text-editor',
      'atom-gmail:send-email', () => this.sendEmail()));
    this.subscriptions.add(atom.commands.add('atom-workspace',
      'atom-gmail:authenticate', () => this.authenticate()));
  },

  deactivate() {
    this.authView.destroy();
    return this.subscriptions.dispose();
  },

  serialize() {
    return {
      authViewState: this.authView.serialize()
    };
  },

  getCodeCSS() {
    css_choice = atom.config.get('atom-gmail.code_highlighting') + '.css';
    atom_path = atom.configDirPath;

    css_path = path.join(atom_path, 'packages', 'atom-gmail', 'lib', 'styles', css_choice);
    css = fs.readFileSync(css_path, 'utf8');
    return css;
  },

  getTextCSS() {
    var css = [];
    css.push('.markdown-body {');
    css.push('	box-sizing: border-box;');
    css.push('  min-width: 200px;');
    css.push('	max-width: ' + atom.config.get('atom-gmail.max_width') + ';');
    if (atom.config.get('atom-gmail.centered')) {
      css.push('  margin: 0 auto;');
    }
    css.push('	padding: 45px;');
    css.push('}');
    css = css.join('\n');

    atom_path = atom.configDirPath;
    css_path = path.join(atom_path, 'packages', 'atom-gmail', 'lib', 'document_styles', 'github-markdown.css');
    css += fs.readFileSync(css_path, 'utf8');
    return css;
  },

  getEmailObject() {
    [metadata, text] = this.parseMarkdown();

    var emailObject = {
      'to': metadata.to,
      'cc': metadata.cc,
      'subject': metadata.subject,
    };

    if (metadata.type != 'undefined') {
      emailObject['type'] = 'plain';
      emailObject['message'] = text;
      return emailObject;
    }

    var html = [];
    html.push('<article class="markdown-body">');
    html.push(md.render(text));
    html.push('</article>');
    html = html.join('\n');

    var css = this.getCodeCSS();
    html = juice.inlineContent(html, css);
    css = this.getTextCSS();
    html = juice.inlineContent(html, css);

    emailObject['type'] = 'plain';
    emailObject['message'] = html;
    return emailObject;
  },

  parseMarkdown() {
    const editor = atom.workspace.getActiveTextEditor();

    // Make sure first line has ---
    first_row_text = editor.lineTextForBufferRow(0);
    if (first_row_text != '---') {
      var msg = 'File does not contain YAML header';
      atom.notifications.addError(msg);
      throw msg;
    }

    // Find first following line with ---
    var numberOfLines = editor.getLineCount();
    var forwardRange = [new Point(1, 0), new Point(numberOfLines + 1, 0)];

    var yamlEnd = null;
    editor.scanInBufferRange(/^---\r?$/g, forwardRange, function(result) {
      yamlEnd = result.range.end.row;
      return result.stop();
    });

    var yaml_range = new Range(new Point(1, 0), new Point(yamlEnd, 0));
    var yaml_text = editor.getTextInBufferRange(yaml_range);
    var metadata = yaml.safeLoad(yaml_text);

    var text_range = new Range(new Point(yamlEnd + 1, 0), new Point(numberOfLines + 1, 0));
    var text = editor.getTextInBufferRange(text_range);

    return [metadata, text];
  },

  sendEmail() {
    var credentials = JSON.parse(atom.config.get('atom-gmail.client_secret'));

    var clientSecret = credentials.installed.client_secret;
    var clientId = credentials.installed.client_id;
    var redirectUrl = credentials.installed.redirect_uris[0];
    var auth = new GoogleAuth();
    var oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);

    var token = atom.config.get('atom-gmail.oauth_token');
    oauth2Client.credentials = JSON.parse(token);

    try {
      this.sendMessage(oauth2Client, this.getEmailObject());
    } catch (e) {
      console.error(e);
    }
  },

  authenticate() {
    console.log('Starting authenticate function');
    var clientSecretText = atom.config.get('atom-gmail.client_secret');
    if (clientSecretText == '') {
      atom.notifications.addError('Client Secret field in configuration is empty.');
      throw 'Client Secret field in configuration is empty.';
    } else {
      var credentials = JSON.parse(clientSecretText);
      this.authorize(credentials, { callback: (text) => console.log(String(text)) });
    }
  },

  authorize(credentials, callback) {
    var clientSecret = credentials.installed.client_secret;
    var clientId = credentials.installed.client_id;
    var redirectUrl = credentials.installed.redirect_uris[0];
    var auth = new GoogleAuth();
    var oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);

    // Check if we have previously stored a token.
    try {
      token = atom.config.get('atom-gmail.oauth_token');
      oauth2Client.credentials = JSON.parse(token);
      atom.notifications.addError('Authentication already completed. Send an email with "Atom Gmail: Send Email"');
    } catch (e) {
      this.getNewToken(oauth2Client, callback);
    }
  },

  SCOPES: [
    'https://www.googleapis.com/auth/gmail.compose',
    'https://www.googleapis.com/auth/gmail.metadata'
  ],

  /**
   * Get and store new token after prompting for user authorization, and then
   * execute the given callback with the authorized OAuth2 client.
   *
   * @param {google.auth.OAuth2} oauth2Client The OAuth2 client to get token for.
   * @param {getEventsCallback} callback The callback to call with the authorized
   *     client.
   */
  getNewToken(oauth2Client, callback) {
    var authUrl = oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: this.SCOPES
    });
    console.log('Authorize this app by visiting this url: ', authUrl);
    opn(authUrl);
    this.authView.open();
  },

  makeBody(emailObject) {
    var str = [];
    if (emailObject.type == 'plain') {
      str.push("Content-Type: text/plain; charset=\"UTF-8\"\n");
    } else {
      str.push("Content-Type: text/html; charset=\"UTF-8\"\n");
    }
    str.push("MIME-Version: 1.0\n");
    str.push("Content-Transfer-Encoding: 7bit\n");
    if (emailObject.to) {
      str.push("to: ", emailObject.to, "\n");
    } else {
      throw 'To field is missing';
    }
    if (emailObject.cc) {
      str.push("cc: ", emailObject.cc, "\n");
    }
    if (emailObject.bcc) {
      str.push("bcc: ", emailObject.bcc, "\n");
    }
    if (emailObject.from) {
      str.push("from: ", emailObject.from, "\n");
    }
    if (emailObject.subject) {
      str.push("subject: ", emailObject.subject, "\n\n");
      // TODO warn for empty subject
    } else {
      str.push("subject: \n\n");
    }
    if (emailObject.message) {
      str.push(emailObject.message);
    }
    str = str.join('');
    var encodedMail = new Buffer(str).toString("base64").replace(/\+/g, '-').replace(/\//g, '_');
    return encodedMail;
  },

  sendMessage(auth, emailObject) {
    var gmail = google.gmail('v1');
    var raw = this.makeBody(emailObject);
    gmail.users.messages.send({
      auth: auth,
      userId: 'me',
      resource: {
        raw: raw
      }
    }, function(err, response) {
      console.log(err || response);
    });
    var msg = [];
    msg.push('Email successfully sent');
    msg.push('- To: ' + emailObject.to);
    msg = msg.join('\n');
    atom.notifications.addSuccess(msg);
  },
};